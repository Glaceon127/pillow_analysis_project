"""漏洞模式分析模块。

输入：
- CVE 列表（建议使用 pillow_cves_with_commits.json）
- 可选：commit 索引（hash -> commit dict），用于推导修复提交时间

输出：用于可视化/报告的统计信息（纯 dict，可 JSON 化）。
"""

from __future__ import annotations

from collections import Counter
from typing import Any, Dict, List, Optional

import pandas as pd


class VulnerabilityAnalyzer:
    def analyze(self, cves: List[Dict[str, Any]], commit_index: Optional[Dict[str, Dict[str, Any]]] = None) -> Dict[str, Any]:
        cves = cves or []
        commit_index = commit_index or {}

        if not cves:
            return {
                'total_cves': 0,
                'with_cve_id': 0,
                'matched_cves': 0,
                'match_types_top': [],
                'cves_by_month': [],
                'matched_by_month': [],
                'fix_commit_date_stats': {
                    'with_fix_commit_date': 0,
                    'min': None,
                    'max': None,
                },
            }

        df = pd.DataFrame(cves)
        df['id'] = df.get('id', '').fillna('')
        df['matched'] = df.get('matched', False).fillna(False).astype(bool)

        # published timeline
        if 'published' in df.columns:
            df['published_dt'] = pd.to_datetime(df['published'], errors='coerce', utc=True)
        else:
            df['published_dt'] = pd.NaT

        total_cves = int(len(df))
        with_cve_id = int((df['id'].astype(str).str.startswith('CVE-')).sum())
        matched_cves = int(df['matched'].sum())

        # match types distribution
        mt_counter: Counter[str] = Counter()
        for mts in df.get('match_types', []):
            if isinstance(mts, list):
                mt_counter.update([m for m in mts if isinstance(m, str) and m])
            elif isinstance(mts, str) and mts:
                mt_counter.update([x for x in mts.split('|') if x])
        match_types_top = [{'type': t, 'count': int(n)} for t, n in mt_counter.most_common(10)]

        # cves by month
        cves_by_month = []
        matched_by_month = []
        if df['published_dt'].notna().any():
            g = df.dropna(subset=['published_dt']).copy()
            g['month'] = g['published_dt'].dt.to_period('M').astype(str)
            bym = g.groupby('month').size().reset_index(name='count').sort_values('month')
            cves_by_month = bym.to_dict(orient='records')

            gbm = g[g['matched']].groupby('month').size().reset_index(name='count').sort_values('month')
            matched_by_month = gbm.to_dict(orient='records')

        # infer fix commit date if possible
        fix_dates: List[pd.Timestamp] = []
        for item in cves:
            if not item.get('matched'):
                continue
            hashes = item.get('matched_commits') or []
            if not isinstance(hashes, list):
                continue
            for h in hashes:
                cm = commit_index.get(h)
                if not cm:
                    continue
                dt = pd.to_datetime(cm.get('date'), errors='coerce', utc=True)
                if pd.notna(dt):
                    fix_dates.append(dt)

        fix_commit_date_stats = {
            'with_fix_commit_date': int(len(fix_dates)),
            'min': min(fix_dates).isoformat() if fix_dates else None,
            'max': max(fix_dates).isoformat() if fix_dates else None,
        }

        return {
            'total_cves': total_cves,
            'with_cve_id': with_cve_id,
            'matched_cves': matched_cves,
            'match_types_top': match_types_top,
            'cves_by_month': cves_by_month,
            'matched_by_month': matched_by_month,
            'fix_commit_date_stats': fix_commit_date_stats,
        }
